"use strict";(self.webpackChunk_inversifyjs_framework_docs_site=self.webpackChunk_inversifyjs_framework_docs_site||[]).push([["2386"],{8547:function(e,n,r){r.r(n),r.d(n,{metadata:()=>t,default:()=>y,frontMatter:()=>m,contentTitle:()=>f,toc:()=>v,assets:()=>x});var t=JSON.parse('{"id":"fundamentals/controller","title":"Controller","description":"Controllers are classes annotated with the @Controller() decorator. They group request handlers for a feature area. A controller defines a base path and one or more route handlers using method decorators.","source":"@site/docs/fundamentals/controller.mdx","sourceDirName":"fundamentals","slug":"/fundamentals/controller","permalink":"/framework/docs/fundamentals/controller","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Controller"},"sidebar":"httpSidebar","previous":{"title":"Getting started","permalink":"/framework/docs/introduction/getting-started"},"next":{"title":"Error Filter","permalink":"/framework/docs/fundamentals/error-filter"}}'),o=r(6820),s=r(4912),a=r(6011),i=r(9694),l=r(5824),c=r(1496),d=r(1640),u=r(328),h=r(7508),p=r(6933);let m={sidebar_position:1,title:"Controller"},f="Controller",x={},v=[{value:"Basic example",id:"basic-example",level:2},{value:"Registering a controller",id:"registering-a-controller",level:2},{value:"Implementation approaches",id:"implementation-approaches",level:2},{value:"1. Non-native types (Recommended)",id:"1-non-native-types-recommended",level:3},{value:"2. Native types (Advanced)",id:"2-native-types-advanced",level:3},{value:"Inheritance",id:"inheritance",level:2},{value:"How inheritance works",id:"how-inheritance-works",level:3}];function g(e){let n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"controller",children:"Controller"})}),"\n",(0,o.jsxs)(n.p,{children:["Controllers are classes annotated with the ",(0,o.jsx)(n.code,{children:"@Controller()"})," decorator. They group request handlers for a feature area. A controller defines a base path and one or more route handlers using ",(0,o.jsx)(n.a,{href:"../../api/decorators/#http-methods",children:"method decorators"}),"."]}),"\n",(0,o.jsx)(n.admonition,{title:"Controller and injectable decorators",type:"info",children:(0,o.jsxs)(n.p,{children:["You don't need to add ",(0,o.jsx)(n.code,{children:"@injectable()"}),". The ",(0,o.jsx)(n.code,{children:"@Controller()"})," decorator already applies it for you."]})}),"\n",(0,o.jsx)(n.h2,{id:"basic-example",children:"Basic example"}),"\n",(0,o.jsx)(n.p,{children:"A minimal controller with one route:"}),"\n",(0,o.jsx)(u.A,{language:"ts",children:a}),"\n",(0,o.jsx)(n.h2,{id:"registering-a-controller",children:"Registering a controller"}),"\n",(0,o.jsx)(n.p,{children:"Register controllers in your container. Bind your controller class and choose a scope."}),"\n",(0,o.jsx)(u.A,{language:"ts",children:"const container: Container = new Container();\n// Register the controller so the adapter can discover it\ncontainer.bind(MessagesController).toSelf().inSingletonScope();"}),"\n",(0,o.jsxs)(n.p,{children:["When you call ",(0,o.jsx)(n.code,{children:"build()"})," on your server adapter, it builds routes from controller metadata at runtime."]}),"\n",(0,o.jsx)(n.admonition,{title:"Controller registration order",type:"tip",children:(0,o.jsxs)(n.p,{children:["Controllers are registered in descending order of priority (highest first). Use the ",(0,o.jsx)(n.code,{children:"priority"})," option in ",(0,o.jsx)(n.code,{children:"@Controller()"})," to control route evaluation order. This is useful for ensuring specific routes are matched before more general ones, or for implementing custom fallback handlers like a 404 route. See the ",(0,o.jsx)(n.a,{href:"../../api/decorators/#controller",children:"Controller decorator API"})," for details."]})}),"\n",(0,o.jsx)(n.h2,{id:"implementation-approaches",children:"Implementation approaches"}),"\n",(0,o.jsx)(n.p,{children:"There are two complementary ways to write controller routes in Inversify HTTP. You can keep your handlers framework-agnostic and let Inversify send the response for you, or you can opt into native adapter types and take full control of the underlying framework's response flow."}),"\n",(0,o.jsx)(n.h3,{id:"1-non-native-types-recommended",children:"1. Non-native types (Recommended)"}),"\n",(0,o.jsxs)(n.p,{children:["With the framework-agnostic approach, your controller methods return values and Inversify converts them into HTTP responses. The adapter decides how to shape the response based on the value: strings are sent as plain text, objects (including undefined) are sent as JSON, Node streams are piped as streaming responses, and primitive values like numbers or booleans are stringified as text. The status code is 200 by default, but you can override it per route with the ",(0,o.jsx)(n.code,{children:"@StatusCode()"})," decorator or by returning a typed ",(0,o.jsx)(n.code,{children:"HttpResponse"})," (for example, ",(0,o.jsx)(n.code,{children:"new CreatedHttpResponse(body)"})," or throwing an ",(0,o.jsx)(n.code,{children:"ErrorHttpResponse"}),"). This keeps controllers portable across adapters and focuses them on business logic rather than framework details."]}),"\n",(0,o.jsx)(u.A,{language:"ts",children:"@Controller('/users')\nexport class NonNativeUsersController {\n  // Return plain value - Inversify converts to JSON response\n  @Get()\n  @SetHeader('X-Custom-Header', 'CustomValue')\n  public async getUsers(): Promise<User[]> {\n    return [\n      { email: 'john@example.com', id: 1, name: 'John Doe' },\n      { email: 'jane@example.com', id: 2, name: 'Jane Smith' },\n    ];\n  }\n\n  // Return specific HttpResponse for custom status codes\n  @Post()\n  public async createUser(\n    @Body() userData: CreateUserRequest,\n  ): Promise<CreatedHttpResponse> {\n    const newUser: User = {\n      email: userData.email,\n      id: Math.random(),\n      name: userData.name,\n    };\n\n    return new CreatedHttpResponse(newUser);\n  }\n\n  // Throw ErrorHttpResponse for error conditions\n  @Get('/not-found')\n  public async getUserNotFound(): Promise<never> {\n    throw new ErrorHttpResponse(\n      HttpStatusCode.NOT_FOUND,\n      { message: 'The requested user does not exist' },\n      'The requested user does not exist',\n    );\n  }\n\n  // Return string directly - sent as text response\n  @Get('/status')\n  public async getStatus(): Promise<string> {\n    return 'Service is healthy';\n  }\n}"}),"\n",(0,o.jsx)(n.h3,{id:"2-native-types-advanced",children:"2. Native types (Advanced)"}),"\n",(0,o.jsxs)(n.p,{children:["If you need direct access to adapter features, inject native types with ",(0,o.jsx)(n.code,{children:"@Response()"})," and ",(0,o.jsx)(n.code,{children:"@Next()"}),". In this mode you're responsible for the full response lifecycle: setting headers, choosing the status code, sending the body (or streaming), and deciding whether to call ",(0,o.jsx)(n.code,{children:"next()"})," to continue the pipeline. This trades portability for full control and is useful for advanced scenarios like fine-grained caching headers, streaming, or integrating with middleware that expects native objects."]}),"\n",(0,o.jsx)(n.p,{children:"Usage with different adapters:"}),"\n",(0,o.jsxs)(h.A,{children:[(0,o.jsx)(p.A,{value:"express4",label:"Express 4",children:(0,o.jsx)(u.A,{language:"ts",children:i})}),(0,o.jsx)(p.A,{value:"express5",label:"Express 5",children:(0,o.jsx)(u.A,{language:"ts",children:l})}),(0,o.jsx)(p.A,{value:"fastify",label:"Fastify",children:(0,o.jsx)(u.A,{language:"ts",children:c})}),(0,o.jsx)(p.A,{value:"hono",label:"Hono",children:(0,o.jsx)(u.A,{language:"ts",children:d})})]}),"\n",(0,o.jsx)(n.admonition,{title:"When to use native types",type:"tip",children:(0,o.jsx)(n.p,{children:"Reach for native types when you need precise control over the HTTP exchange\u2014streaming large payloads, fine-tuning caching and headers, squeezing out adapter-specific performance, or interoperating with middleware that expects a native response object. For most routes, the framework-agnostic approach remains simpler, more portable, and easier to test."})}),"\n",(0,o.jsx)(n.admonition,{title:"Important: Choose one approach per route",type:"warning",children:(0,o.jsxs)(n.p,{children:["Avoid mixing modes within the same route. If you inject ",(0,o.jsx)(n.code,{children:"@Response()"})," or ",(0,o.jsx)(n.code,{children:"@Next()"}),", your handler should manage the response entirely and typically return ",(0,o.jsx)(n.code,{children:"void"})," (or the framework ",(0,o.jsx)(n.code,{children:"Response"})," for Hono). Conversely, when you return values for Inversify to send, don't also write to the native response object."]})}),"\n",(0,o.jsx)(n.h2,{id:"inheritance",children:"Inheritance"}),"\n",(0,o.jsx)(n.p,{children:"Controllers support inheritance, allowing you to define base controllers with common route handlers that can be reused and optionally overridden in derived controllers. This promotes code reuse and consistency across similar endpoints."}),"\n",(0,o.jsx)(u.A,{language:"ts",children:"abstract class BaseResourceController {\n  @Get()\n  public async list(): Promise<Resource[]> {\n    return [\n      { id: 1, name: 'Resource 1' },\n      { id: 2, name: 'Resource 2' },\n    ];\n  }\n\n  @Get('/:id')\n  public async getById(\n    @Params({\n      name: 'id',\n    })\n    id: string,\n  ): Promise<Resource> {\n    return { id: parseInt(id), name: `Resource ${id}` };\n  }\n}\n\n@Controller('/users')\nexport class UsersController extends BaseResourceController {}\n\n@Controller('/products')\nexport class ProductsController extends BaseResourceController {\n  // Override the list method with custom implementation\n  @Get()\n  public override async list(): Promise<Resource[]> {\n    return [\n      { id: 1, name: 'Product A' },\n      { id: 2, name: 'Product B' },\n      { id: 3, name: 'Product C' },\n    ];\n  }\n}"}),"\n",(0,o.jsx)(n.h3,{id:"how-inheritance-works",children:"How inheritance works"}),"\n",(0,o.jsx)(n.p,{children:"When a controller extends a base class:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"All route handlers from the base controller are inherited"})," - The derived controller automatically includes all HTTP method decorators (",(0,o.jsx)(n.code,{children:"@Get()"}),", ",(0,o.jsx)(n.code,{children:"@Post()"}),", etc.) from its parent classes"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Routes can be overridden"})," - If a derived controller defines a route with the same HTTP method and path as its base class, the derived implementation takes precedence"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Base path applies to all routes"})," - The ",(0,o.jsx)(n.code,{children:"@Controller()"})," path specified on the derived class applies to both inherited and overridden routes"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Metadata walks up the prototype chain"})," - The framework traverses the entire inheritance hierarchy to collect all route metadata"]}),"\n"]}),"\n",(0,o.jsx)(n.admonition,{title:"Route collision resolution",type:"info",children:(0,o.jsx)(n.p,{children:"When a derived controller defines a route with the same HTTP method and path as its parent, the derived controller's implementation takes precedence. This allows you to selectively customize behavior while keeping the base implementation for other routes."})})]})}function y(e={}){let{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(g,{...e})}):g(e)}},6011:function(e){e.exports="@Controller('/messages')\nexport class MessagesController {\n  @Get('/hello')\n  public async sayHello(): Promise<Message> {\n    return { content: 'world' };\n  }\n}"},5824:function(e){e.exports="@Controller('/message')\nexport class ResponseExpressController {\n  @Get()\n  public async sendMessage(\n    @Response() response: express.Response,\n  ): Promise<void> {\n    response.send({ message: 'hello' });\n  }\n}\n"},9694:function(e){e.exports="@Controller('/message')\nexport class ResponseExpressController {\n  @Get()\n  public async sendMessage(\n    @Response() response: express.Response,\n  ): Promise<void> {\n    response.send({ message: 'hello' });\n  }\n}\n"},1496:function(e){e.exports="@Controller('/message')\nexport class ResponseFastifyController {\n  @Get()\n  public async sendMessage(@Response() reply: FastifyReply): Promise<void> {\n    reply.send({ message: 'hello' });\n  }\n}\n"},1640:function(e){e.exports="import { Controller, Get } from '@inversifyjs/http-core';\nimport { Context } from '@inversifyjs/http-hono';\nimport { type Context as HonoContext } from 'hono';\n\n@Controller('/message')\nexport class ResponseHonoController {\n  @Get()\n  public async sendMessage(@Context() context: HonoContext): Promise<Response> {\n    return context.json({ message: 'hello' });\n  }\n}\n"},6933:function(e,n,r){r.d(n,{A:()=>s});var t=r(6820);r(5080);var o=r(4921);function s({children:e,hidden:n,className:r}){return(0,t.jsx)("div",{role:"tabpanel",className:(0,o.A)("tabItem_vHDL",r),hidden:n,children:e})}},7508:function(e,n,r){r.d(n,{A:()=>y});var t=r(6820),o=r(5080),s=r(4921),a=r(5113),i=r(1458),l=r(3357),c=r(4356),d=r(9239),u=r(2124),h=r(612);function p(e){return o.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,o.isValidElement)(e)&&function(e){let{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function m({value:e,tabValues:n}){return n.some(n=>n.value===e)}var f=r(1712);function x({className:e,block:n,selectedValue:r,selectValue:o,tabValues:a}){let l=[],{blockElementScrollPositionUntilNextRender:c}=(0,i.a_)(),d=e=>{let n=e.currentTarget,t=a[l.indexOf(n)].value;t!==r&&(c(n),o(t))},u=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{let r=l.indexOf(e.currentTarget)+1;n=l[r]??l[0];break}case"ArrowLeft":{let r=l.indexOf(e.currentTarget)-1;n=l[r]??l[l.length-1]}}n?.focus()};return(0,t.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":n},e),children:a.map(({value:e,label:n,attributes:o})=>(0,t.jsx)("li",{role:"tab",tabIndex:r===e?0:-1,"aria-selected":r===e,ref:e=>{l.push(e)},onKeyDown:u,onClick:d,...o,className:(0,s.A)("tabs__item","tabItem_pML9",o?.className,{"tabs__item--active":r===e}),children:n??e},e))})}function v({lazy:e,children:n,selectedValue:r}){let a=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){let e=a.find(e=>e.props.value===r);return e?(0,o.cloneElement)(e,{className:(0,s.A)("margin-top--md",e.props.className)}):null}return(0,t.jsx)("div",{className:"margin-top--md",children:a.map((e,n)=>(0,o.cloneElement)(e,{key:n,hidden:e.props.value!==r}))})}function g(e){let n=function(e){let n,{defaultValue:r,queryString:t=!1,groupId:s}=e,a=function(e){let{values:n,children:r}=e;return(0,o.useMemo)(()=>{let e=n??p(r).map(({props:{value:e,label:n,attributes:r,default:t}})=>({value:e,label:n,attributes:r,default:t})),t=(0,u.XI)(e,(e,n)=>e.value===n.value);if(t.length>0)throw Error(`Docusaurus error: Duplicate values "${t.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`);return e},[n,r])}(e),[i,f]=(0,o.useState)(()=>(function({defaultValue:e,tabValues:n}){if(0===n.length)throw Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:n}))throw Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}let r=n.find(e=>e.default)??n[0];if(!r)throw Error("Unexpected error: 0 tabValues");return r.value})({defaultValue:r,tabValues:a})),[x,v]=function({queryString:e=!1,groupId:n}){let r=(0,l.W6)(),t=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,d.aZ)(t),(0,o.useCallback)(e=>{if(!t)return;let n=new URLSearchParams(r.location.search);n.set(t,e),r.replace({...r.location,search:n.toString()})},[t,r])]}({queryString:t,groupId:s}),[g,y]=function({groupId:e}){let n=e?`docusaurus.tab.${e}`:null,[r,t]=(0,h.Dv)(n);return[r,(0,o.useCallback)(e=>{n&&t.set(e)},[n,t])]}({groupId:s}),j=m({value:n=x??g,tabValues:a})?n:null;return(0,c.A)(()=>{j&&f(j)},[j]),{selectedValue:i,selectValue:(0,o.useCallback)(e=>{if(!m({value:e,tabValues:a}))throw Error(`Can't select invalid tab value=${e}`);f(e),v(e),y(e)},[v,y,a]),tabValues:a}}(e);return(0,t.jsxs)("div",{className:(0,s.A)(a.G.tabs.container,"tabs-container","tabList_eMv8"),children:[(0,t.jsx)(x,{...n,...e}),(0,t.jsx)(v,{...n,...e})]})}function y(e){let n=(0,f.A)();return(0,t.jsx)(g,{...e,children:p(e.children)},String(n))}}}]);