"use strict";(self.webpackChunk_inversifyjs_framework_docs_site=self.webpackChunk_inversifyjs_framework_docs_site||[]).push([["8367"],{4925:function(e,i,n){n.r(i),n.d(i,{frontMatter:()=>l,toc:()=>c,default:()=>h,metadata:()=>s,assets:()=>o,contentTitle:()=>a});var s=JSON.parse('{"id":"introduction/philosophy","title":"Philosophy","description":"The InversifyJS OpenAPI HTTP library is built on several core principles that prioritize OpenAPI 3.1 specification compliance, class-based API contracts, and developer experience. This document outlines the design decisions and philosophies that guide the development of this library.","source":"@site/openapi-docs/introduction/philosophy.mdx","sourceDirName":"introduction","slug":"/introduction/philosophy","permalink":"/framework/openapi/introduction/philosophy","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Philosophy"},"sidebar":"openApiSidebar","previous":{"title":"Getting started","permalink":"/framework/openapi/introduction/getting-started"},"next":{"title":"Decorator","permalink":"/framework/openapi/api/decorators"}}'),t=n(6820),r=n(7588);let l={sidebar_position:2,title:"Philosophy"},a="Design Philosophy",o={},c=[{value:"Core Principles",id:"core-principles",level:2},{value:"1. OpenAPI 3.1 First Design",id:"1-openapi-31-first-design",level:3},{value:"Key Design Decisions:",id:"key-design-decisions",level:4},{value:"2. Class-Based API Contracts",id:"2-class-based-api-contracts",level:3},{value:"Design Implementation:",id:"design-implementation",level:4},{value:"3. Decorator-Driven Documentation",id:"3-decorator-driven-documentation",level:3},{value:"4. Flexible Schema Building",id:"4-flexible-schema-building",level:3},{value:"Static Schema Definition:",id:"static-schema-definition",level:4},{value:"Dynamic Schema Building:",id:"dynamic-schema-building",level:4},{value:"Architectural Decisions",id:"architectural-decisions",level:2},{value:"Metadata Storage Strategy",id:"metadata-storage-strategy",level:3},{value:"Schema Reference Resolution",id:"schema-reference-resolution",level:3},{value:"Well-Known Type Support",id:"well-known-type-support",level:3},{value:"Framework Integration Philosophy",id:"framework-integration-philosophy",level:2},{value:"Universal Compatibility",id:"universal-compatibility",level:3},{value:"InversifyJS Integration",id:"inversifyjs-integration",level:3},{value:"Inspiration and Acknowledgments",id:"inspiration-and-acknowledgments",level:2},{value:"NestJS OpenAPI Module",id:"nestjs-openapi-module",level:3},{value:"Developer Experience Goals",id:"developer-experience-goals",level:2},{value:"Minimal Learning Curve",id:"minimal-learning-curve",level:3},{value:"Powerful Flexibility",id:"powerful-flexibility",level:3},{value:"Tooling Integration",id:"tooling-integration",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){let i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"design-philosophy",children:"Design Philosophy"})}),"\n",(0,t.jsx)(i.p,{children:"The InversifyJS OpenAPI HTTP library is built on several core principles that prioritize OpenAPI 3.1 specification compliance, class-based API contracts, and developer experience. This document outlines the design decisions and philosophies that guide the development of this library."}),"\n",(0,t.jsx)(i.h2,{id:"core-principles",children:"Core Principles"}),"\n",(0,t.jsx)(i.h3,{id:"1-openapi-31-first-design",children:"1. OpenAPI 3.1 First Design"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"OpenAPI 3.1 is great, and our library must reflect that excellence."})}),"\n",(0,t.jsx)(i.p,{children:"The library is designed with OpenAPI 3.1 specification as the primary consideration. Rather than creating our own abstraction layer, we strive to provide contracts that are as close as possible to the OpenAPI 3.1 specification itself."}),"\n",(0,t.jsx)(i.h4,{id:"key-design-decisions",children:"Key Design Decisions:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Direct Spec Mapping"}),": All decorators and types directly correspond to OpenAPI 3.1 specification elements"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"JSON Schema Integration"}),": Full support for JSON Schema 2020-12, which is the foundation of OpenAPI 3.1"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"No Abstraction Overhead"}),": Minimal layers between developer code and the final OpenAPI specification"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Future-Proof"}),": Built to leverage OpenAPI 3.1 features like improved JSON Schema support and webhooks"]}),"\n"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-typescript",children:"// Direct mapping to OpenAPI 3.1 specification\n@OasResponse(HttpStatusCode.Ok, {\n  description: 'Successful response',\n  content: {\n    'application/json': {\n      schema: { type: 'object', properties: { id: { type: 'string' } } }\n    }\n  }\n})\n"})}),"\n",(0,t.jsx)(i.h3,{id:"2-class-based-api-contracts",children:"2. Class-Based API Contracts"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Classes are a great way to represent API contracts."})}),"\n",(0,t.jsx)(i.p,{children:"We believe that TypeScript classes provide an excellent foundation for documenting and structuring APIs. Classes offer:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Type Safety"}),": Compile-time checking and IntelliSense support"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Discoverability"}),": Clear structure that developers can explore"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Reusability"}),": Schema definitions that can be shared across multiple endpoints"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Validation"}),": Integration with runtime validation systems"]}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"design-implementation",children:"Design Implementation:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-typescript",children:"@OasSchema()\nexport class CreateUserRequest {\n  @OasSchemaProperty({ type: 'string', minLength: 1 })\n  name!: string;\n\n  @OasSchemaProperty({ type: 'string', format: 'email' })\n  email!: string;\n\n  @OasSchemaOptionalProperty({ type: 'number', minimum: 18 })\n  age?: number;\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"3-decorator-driven-documentation",children:"3. Decorator-Driven Documentation"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Metadata should live close to the code it describes."})}),"\n",(0,t.jsx)(i.p,{children:"Following the principle of locality, OpenAPI metadata is attached directly to the classes and methods it documents through TypeScript decorators. This approach:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Reduces Drift"}),": Documentation stays synchronized with code changes"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Improves Maintainability"}),": Changes to endpoints automatically update documentation"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Enhances Developer Experience"}),": Documentation is written where the code is written"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"4-flexible-schema-building",children:"4. Flexible Schema Building"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Support both static and dynamic schema generation."})}),"\n",(0,t.jsx)(i.p,{children:"The library supports two approaches to schema definition:"}),"\n",(0,t.jsx)(i.h4,{id:"static-schema-definition",children:"Static Schema Definition:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-typescript",children:"@OasRequestBody({\n  content: {\n    'application/json': {\n      schema: { type: 'object', properties: { name: { type: 'string' } } }\n    }\n  }\n})\n"})}),"\n",(0,t.jsx)(i.h4,{id:"dynamic-schema-building",children:"Dynamic Schema Building:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-typescript",children:"@OasRequestBody((toSchema) => ({\n  content: {\n    'application/json': {\n      schema: toSchema(CreateUserRequest)\n    }\n  },\n  required: true\n}))\n"})}),"\n",(0,t.jsx)(i.p,{children:"This flexibility allows developers to choose the approach that best fits their use case while maintaining type safety and schema reusability."}),"\n",(0,t.jsx)(i.h2,{id:"architectural-decisions",children:"Architectural Decisions"}),"\n",(0,t.jsx)(i.h3,{id:"metadata-storage-strategy",children:"Metadata Storage Strategy"}),"\n",(0,t.jsx)(i.p,{children:"The library uses TypeScript's reflect-metadata system to store OpenAPI metadata directly on classes and methods. This approach provides:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Performance"}),": Metadata access is fast and doesn't require external registries"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Isolation"}),": Each class/method manages its own metadata independently"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Flexibility"}),": Metadata can be built incrementally through multiple decorators"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"schema-reference-resolution",children:"Schema Reference Resolution"}),"\n",(0,t.jsxs)(i.p,{children:["Class-based schemas are automatically resolved into OpenAPI references (",(0,t.jsx)(i.code,{children:"$ref"}),"), promoting:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Reusability"}),": Schemas defined once can be referenced multiple times"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Specification Size"}),": Reduced duplication in the final OpenAPI document"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Standards Compliance"}),": Follows OpenAPI best practices for component reuse"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"well-known-type-support",children:"Well-Known Type Support"}),"\n",(0,t.jsx)(i.p,{children:"The library automatically handles common JavaScript types. This reduces boilerplate while maintaining specification accuracy."}),"\n",(0,t.jsx)(i.h2,{id:"framework-integration-philosophy",children:"Framework Integration Philosophy"}),"\n",(0,t.jsx)(i.h3,{id:"universal-compatibility",children:"Universal Compatibility"}),"\n",(0,t.jsx)(i.p,{children:"The library is designed to work with multiple HTTP frameworks (Express, Fastify, Hono) through:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Framework-Agnostic Core"}),": Core functionality doesn't depend on specific HTTP frameworks"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Adapter Pattern"}),": Framework-specific implementations handle integration details"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Swagger UI Providers"}),": Dedicated providers for each supported framework"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"inversifyjs-integration",children:"InversifyJS Integration"}),"\n",(0,t.jsx)(i.p,{children:"As part of the InversifyJS ecosystem, the library follows dependency injection principles:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Container-Based Setup"}),": OpenAPI documentation is configured through the IoC container"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Metadata Discovery"}),": Automatic discovery of controllers and their OpenAPI metadata"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Lifecycle Management"}),": Proper initialization and cleanup through container lifecycle"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"inspiration-and-acknowledgments",children:"Inspiration and Acknowledgments"}),"\n",(0,t.jsx)(i.h3,{id:"nestjs-openapi-module",children:"NestJS OpenAPI Module"}),"\n",(0,t.jsxs)(i.p,{children:["We acknowledge the excellent work done by the ",(0,t.jsx)(i.a,{href:"https://docs.nestjs.com/openapi/introduction",children:"NestJS OpenAPI module"})," team, which served as inspiration for many design decisions in this library. Key inspirations include:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Decorator-Based Approach"}),": Using decorators for attaching OpenAPI metadata"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Class-Based Schemas"}),": Treating classes as first-class schema definitions"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Automatic Documentation Generation"}),": Building OpenAPI specifications from code metadata"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Framework Integration"}),": Seamless integration with HTTP frameworks"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"However, our library differentiates itself by:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"InversifyJS Integration"}),": Deep integration with the InversifyJS dependency injection ecosystem"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Specification Fidelity"}),": Direct mapping to OpenAPI specification without abstraction layers"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"developer-experience-goals",children:"Developer Experience Goals"}),"\n",(0,t.jsx)(i.h3,{id:"minimal-learning-curve",children:"Minimal Learning Curve"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Familiar Patterns"}),": Developers familiar with decorators will feel at home"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"TypeScript First"}),": Full type safety and IntelliSense support"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Clear Documentation"}),": Comprehensive examples and API documentation"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"powerful-flexibility",children:"Powerful Flexibility"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Progressive Enhancement"}),": Start simple, add complexity as needed"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Escape Hatches"}),": Direct access to OpenAPI specification when needed"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Customization Points"}),": Extensible design for custom requirements"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"tooling-integration",children:"Tooling Integration"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"IDE Support"}),": Full TypeScript integration for autocompletion and error checking"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Build-Time Validation"}),": Catch specification errors during development"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Runtime Flexibility"}),": Dynamic schema building for complex scenarios"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(i.p,{children:"The InversifyJS OpenAPI HTTP library represents a thoughtful balance between specification compliance, developer experience, and architectural flexibility. By prioritizing OpenAPI 3.1 as a first-class citizen and embracing class-based API contracts, we provide developers with powerful tools for building well-documented APIs while maintaining the flexibility to handle complex real-world scenarios."}),"\n",(0,t.jsx)(i.p,{children:"Our design philosophy ensures that the library grows with the OpenAPI specification while providing a stable, type-safe foundation for modern API development in the TypeScript ecosystem."})]})}function h(e={}){let{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);